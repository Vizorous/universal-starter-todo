# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AnswerAttempt {
  id: ID!
  createdAt: Date!
  updatedAt: Date!

  """AnswerAttempt  name"""
  name: String!
  description: String
  answers(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: AnswerFilter = {}

    """Paginate before opaque cursor"""
    before: ConnectionCursor

    """Paginate after opaque cursor"""
    after: ConnectionCursor

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int

    """Specify to sort results."""
    sorting: [AnswerSort!] = []
  ): AnswerAttemptAnswersConnection
}

input CursorPaging {
  """Paginate before opaque cursor"""
  before: ConnectionCursor

  """Paginate after opaque cursor"""
  after: ConnectionCursor

  """Paginate first"""
  first: Int

  """Paginate last"""
  last: Int
}

"""Cursor for paging through collections"""
scalar ConnectionCursor

input AnswerFilter {
  and: [AnswerFilter!]
  or: [AnswerFilter!]
  id: AnswerIdFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  questionId: IDFilterComparison
  question: AnswerFilterQuestionFilter
}

input AnswerIdFilterComparison {
  eq: ID
  in: [ID!]
}

input DateFieldComparison {
  is: Boolean
  isNot: Boolean
  eq: DateTime
  neq: DateTime
  gt: DateTime
  gte: DateTime
  lt: DateTime
  lte: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  between: DateFieldComparisonBetween
  notBetween: DateFieldComparisonBetween
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

input IDFilterComparison {
  is: Boolean
  isNot: Boolean
  eq: ID
  neq: ID
  gt: ID
  gte: ID
  lt: ID
  lte: ID
  like: ID
  notLike: ID
  iLike: ID
  notILike: ID
  in: [ID!]
  notIn: [ID!]
}

input AnswerFilterQuestionFilter {
  and: [AnswerFilterQuestionFilter!]
  or: [AnswerFilterQuestionFilter!]
  id: QuestionIdFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
}

input QuestionIdFilterComparison {
  eq: ID
  in: [ID!]
}

input AnswerSort {
  field: AnswerSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AnswerSortFields {
  id
  createdAt
  updatedAt
  questionId
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

type Answer {
  id: ID!
  createdAt: Date!
  updatedAt: Date!

  """Answer  name"""
  value: Float!
  description: String
  questionId: ID!
  answerAttemptId: ID!
  question: Question!
}

type Question {
  id: ID!
  createdAt: Date!
  updatedAt: Date!

  """Question  text"""
  text: String!
  description: String
}

type QuestionDeleteResponse {
  id: ID
  createdAt: Date
  updatedAt: Date

  """Question  text"""
  text: String
  description: String
}

type QuestionEdge {
  """The node containing the Question"""
  node: Question!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type PageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean

  """The cursor of the first returned record."""
  startCursor: ConnectionCursor

  """The cursor of the last returned record."""
  endCursor: ConnectionCursor
}

type QuestionConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [QuestionEdge!]!
}

type AnswerDeleteResponse {
  id: ID
  createdAt: Date
  updatedAt: Date

  """Answer  name"""
  value: Float
  description: String
  questionId: ID
  answerAttemptId: ID
}

type AnswerEdge {
  """The node containing the Answer"""
  node: Answer!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type AnswerConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [AnswerEdge!]!
}

type Prediction {
  id: ID!
  createdAt: Date!
  updatedAt: Date!

  """Prediction  name"""
  value: String!
  calculatedNumbers: String
  answerAttemptId: ID!
  answerAttempt: AnswerAttempt!
}

type PredictionDeleteResponse {
  id: ID
  createdAt: Date
  updatedAt: Date

  """Prediction  name"""
  value: String
  calculatedNumbers: String
  answerAttemptId: ID
}

type PredictionEdge {
  """The node containing the Prediction"""
  node: Prediction!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type PredictionConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [PredictionEdge!]!
}

type AnswerAttemptDeleteResponse {
  id: ID
  createdAt: Date
  updatedAt: Date

  """AnswerAttempt  name"""
  name: String
  description: String
}

type AnswerAttemptEdge {
  """The node containing the AnswerAttempt"""
  node: AnswerAttempt!

  """Cursor for this node."""
  cursor: ConnectionCursor!
}

type AnswerAttemptConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [AnswerAttemptEdge!]!
}

type AnswerAttemptAnswersConnection {
  """Paging information"""
  pageInfo: PageInfo!

  """Array of edges."""
  edges: [AnswerEdge!]!
}

"""Date custom scalar type"""
scalar Date

type Query {
  question(
    """The id of the record to find."""
    id: ID!
  ): Question!
  questions(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: QuestionFilter = {}

    """Paginate before opaque cursor"""
    before: ConnectionCursor

    """Paginate after opaque cursor"""
    after: ConnectionCursor

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int

    """Specify to sort results."""
    sorting: [QuestionSort!] = []
  ): QuestionConnection!
  answer(
    """The id of the record to find."""
    id: ID!
  ): Answer!
  answers(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: AnswerFilter = {}

    """Paginate before opaque cursor"""
    before: ConnectionCursor

    """Paginate after opaque cursor"""
    after: ConnectionCursor

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int

    """Specify to sort results."""
    sorting: [AnswerSort!] = []
  ): AnswerConnection!
  prediction(
    """The id of the record to find."""
    id: ID!
  ): Prediction!
  predictions(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: PredictionFilter = {}

    """Paginate before opaque cursor"""
    before: ConnectionCursor

    """Paginate after opaque cursor"""
    after: ConnectionCursor

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int

    """Specify to sort results."""
    sorting: [PredictionSort!] = []
  ): PredictionConnection!
  answerAttempt(
    """The id of the record to find."""
    id: ID!
  ): AnswerAttempt!
  answerAttempts(
    """Limit or page results."""
    paging: CursorPaging = {first: 10}

    """Specify to filter the records returned."""
    filter: AnswerAttemptFilter = {}

    """Paginate before opaque cursor"""
    before: ConnectionCursor

    """Paginate after opaque cursor"""
    after: ConnectionCursor

    """Paginate first"""
    first: Int

    """Paginate last"""
    last: Int

    """Specify to sort results."""
    sorting: [AnswerAttemptSort!] = []
  ): AnswerAttemptConnection!
}

input QuestionFilter {
  and: [QuestionFilter!]
  or: [QuestionFilter!]
  id: QuestionIdFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
}

input QuestionSort {
  field: QuestionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum QuestionSortFields {
  id
  createdAt
  updatedAt
}

input PredictionFilter {
  and: [PredictionFilter!]
  or: [PredictionFilter!]
  id: PredictionIdFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  value: PredictionValueFilterComparison
}

input PredictionIdFilterComparison {
  eq: ID
  in: [ID!]
}

input PredictionValueFilterComparison {
  is: Boolean
  like: String
  in: [String!]
}

input PredictionSort {
  field: PredictionSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum PredictionSortFields {
  id
  createdAt
  updatedAt
  value
}

input AnswerAttemptFilter {
  and: [AnswerAttemptFilter!]
  or: [AnswerAttemptFilter!]
  id: AnswerAttemptIdFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  name: AnswerAttemptNameFilterComparison
  answers: AnswerAttemptFilterAnswerFilter
}

input AnswerAttemptIdFilterComparison {
  eq: ID
  in: [ID!]
}

input AnswerAttemptNameFilterComparison {
  is: Boolean
  like: String
  in: [String!]
}

input AnswerAttemptFilterAnswerFilter {
  and: [AnswerAttemptFilterAnswerFilter!]
  or: [AnswerAttemptFilterAnswerFilter!]
  id: AnswerIdFilterComparison
  createdAt: DateFieldComparison
  updatedAt: DateFieldComparison
  questionId: IDFilterComparison
}

input AnswerAttemptSort {
  field: AnswerAttemptSortFields!
  direction: SortDirection!
  nulls: SortNulls
}

enum AnswerAttemptSortFields {
  id
  createdAt
  updatedAt
  name
}

type Mutation {
  createOneQuestion(input: CreateOneQuestionInput!): Question!
  updateOneQuestion(input: UpdateOneQuestionInput!): Question!
  deleteOneQuestion(input: DeleteOneQuestionInput!): QuestionDeleteResponse!
  setQuestionOnAnswer(input: SetQuestionOnAnswerInput!): Answer!
  createOneAnswer(input: CreateOneAnswerInput!): Answer!
  updateOneAnswer(input: UpdateOneAnswerInput!): Answer!
  deleteOneAnswer(input: DeleteOneAnswerInput!): AnswerDeleteResponse!
  setAnswerAttemptOnPrediction(input: SetAnswerAttemptOnPredictionInput!): Prediction!
  createOnePrediction(input: CreateOnePredictionInput!): Prediction!
  updateOnePrediction(input: UpdateOnePredictionInput!): Prediction!
  deleteOnePrediction(input: DeleteOnePredictionInput!): PredictionDeleteResponse!
  addAnswersToAnswerAttempt(input: AddAnswersToAnswerAttemptInput!): AnswerAttempt!
  setAnswersOnAnswerAttempt(input: SetAnswersOnAnswerAttemptInput!): AnswerAttempt!
  removeAnswersFromAnswerAttempt(input: RemoveAnswersFromAnswerAttemptInput!): AnswerAttempt!
  createOneAnswerAttempt(input: CreateOneAnswerAttemptInput!): AnswerAttempt!
  updateOneAnswerAttempt(input: UpdateOneAnswerAttemptInput!): AnswerAttempt!
  deleteOneAnswerAttempt(input: DeleteOneAnswerAttemptInput!): AnswerAttemptDeleteResponse!
}

input CreateOneQuestionInput {
  """The record to create"""
  question: CreateQuestion!
}

input CreateQuestion {
  """Question  text"""
  text: String!
  description: String
}

input UpdateOneQuestionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateQuestion!
}

input UpdateQuestion {
  """Question  text"""
  text: String
  description: String
}

input DeleteOneQuestionInput {
  """The id of the record to delete."""
  id: ID!
}

input SetQuestionOnAnswerInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input CreateOneAnswerInput {
  """The record to create"""
  answer: CreateAnswer!
}

input CreateAnswer {
  """Answer  name"""
  value: Float!
  description: String
  questionId: ID!
  answerAttemptId: ID!
}

input UpdateOneAnswerInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateAnswer!
}

input UpdateAnswer {
  """Answer  name"""
  value: Float
  description: String
  questionId: ID
  answerAttemptId: ID
}

input DeleteOneAnswerInput {
  """The id of the record to delete."""
  id: ID!
}

input SetAnswerAttemptOnPredictionInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input CreateOnePredictionInput {
  """The record to create"""
  prediction: CreatePrediction!
}

input CreatePrediction {
  """Prediction  name"""
  value: String!
  calculatedNumbers: String
  answerAttemptId: ID!
}

input UpdateOnePredictionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdatePrediction!
}

input UpdatePrediction {
  """Prediction  name"""
  value: String
  calculatedNumbers: String
  answerAttemptId: ID
}

input DeleteOnePredictionInput {
  """The id of the record to delete."""
  id: ID!
}

input AddAnswersToAnswerAttemptInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input SetAnswersOnAnswerAttemptInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input RemoveAnswersFromAnswerAttemptInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input CreateOneAnswerAttemptInput {
  """The record to create"""
  answerAttempt: CreateAnswerAttempt!
}

input CreateAnswerAttempt {
  """AnswerAttempt  name"""
  name: String!
  description: String
}

input UpdateOneAnswerAttemptInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateAnswerAttempt!
}

input UpdateAnswerAttempt {
  """AnswerAttempt  name"""
  name: String
  description: String
}

input DeleteOneAnswerAttemptInput {
  """The id of the record to delete."""
  id: ID!
}